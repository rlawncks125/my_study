{"version":3,"sources":["webpack:///./src/views/VUEX-view/모듈정의.vue","webpack:///./src/views/VUEX-view/모듈정의.vue?4edd","webpack:///./src/views/VUEX-view/모듈정의.vue?012e"],"names":["class","items","item","key","id","title","content","code","setup","render"],"mappings":"yIACE,eAAoC,MAAhCA,MAAM,YAAW,cAAU,G,EAC/B,eAAM,mB,EACN,eAAM,mB,iHAFN,EACA,EACA,G,mBACA,eAMM,2BANc,EAAAC,OAAK,SAAbC,G,wBAAZ,eAMM,OANsBC,IAAKD,EAAKE,I,CACpC,eAIe,QAHFC,MAAK,gBAAC,iBAAgB,C,8BAAbH,EAAKG,OAAK,OACnBC,QAAO,gBAAC,iBAAkB,C,8BAAfJ,EAAKI,SAAO,OACvBC,KAAI,gBAAC,iBAAe,C,8BAAZL,EAAKK,MAAI,O,2CCJnB,iBAAgB,CAC7BC,MAD6B,WAE3B,IAAMP,EAAQ,eAAS,CACrB,CACEI,MAAO,2BACPE,KAAM,eAAY,khCA+CpB,CACEF,MAAO,KACPE,KAAM,eAAY,+GAOpB,CACEF,MAAO,2BACPE,KAAM,eAAY,6kBA6BpB,CACEF,MAAO,2BACPE,KAAM,eAAY,8oBAuCtB,MAAO,CAAEN,YCtIb,EAAOQ,OAASA,EAED","file":"js/chunk-2d225fb9.f3d2b941.js","sourcesContent":["<template>\n  <h1 class=\"div-line\">모듈 정의 및 사용</h1>\n  <hr />\n  <br />\n  <div v-for=\"item in items\" :key=\"item.id\">\n    <code-convert>\n      <template #title>{{ item.title }} </template>\n      <template #content>{{ item.content }}</template>\n      <template #code>{{ item.code }} </template>\n    </code-convert>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, reactive } from \"vue\";\nimport { codeProcess } from \"@/components/codeConvert.vue\";\n\nexport default defineComponent({\n  setup() {\n    const items = reactive([\n      {\n        title: \"TypeScript를 이용한 index 정의\",\n        code: codeProcess(`// store/index.ts\n\n        import { InjectionKey } from \"vue\";\nimport { createStore, useStore as baseUseStore, Store } from \"vuex\";\n// 모듈 import\nimport { module as ModuleA , IModule as IModuleA  } from \"modules/moduleA\"\nimport { module as ModuleB , IModule as IModuleB  } from \"modules/moduleB\"\n\n\n// 인터페이스 정의\nexport interface State {\n\t/ttcount : number;\n\t/tttitle : string;\n\t/tt// 모듈 정의 \n\t/ttmoduleA ?: ImoduleA(module Interface)\n\t/ttmoduleB ?: ImoduleB(module Interface)\n}\n\n// Symbol를 이용한 키생성\nexport const key: InjectionKey<Store<State>> = Symbol();\n\n\n//store 정의\nexport const store = createStore<State>({\n  /ttstate: {\n  /tt/ttcount: 1,\n  /tt/tttitle: \"타이틀틀\"\n  /tt},\n  /tt// Computed 와 같은 역할\n/tt// 사용할떄 한번만 사용, 데이터 바뀌면 감지해서 바뀜\n/ttgetters: {},\n/tt// 함수\n/ttmutations: {},\n/tt// 비동기 처리 할떄 씀\n/ttactions: {};\n\t// 모듈 사용 ,\n\t/ttmodules : {\n\t/tt/ttmoduleA,\n\t/tt/ttmoduleB \n\t/tt}\n});\n\n// Composition Api에서 접근할떄 이함수를 사용\nexport function useStore(): Store<State> {\n  return baseUseStore(key);\n}`),\n      },\n      {\n        title: \"선언\",\n        code: codeProcess(`\n          //main.ts 선언\nimport { store, key } from \"./store/index\";\n\nvue.use(store , key);\n          `),\n      },\n      {\n        title: \"TypeScript를 이용한 모듈 만들기 1\",\n        code: codeProcess(`\n          // store/modules/module\nimport { Module } from \"vuex\";\nimport { State as rootState } from \"../index\";\n\ninterface IState{\n\t/ttname : string,\n\t/ttdescript : string;\n}\n\nexport const module :Module<IState, rootState> = {\n\t// 호출할떄 [moduleName/호출] 로 호출\n\t// moduleName 은 modules에 정의된 모듈이름 따라감\n  // namespaced: true, \n  // Data 와 같은 역할\n\tstate: { \n\t\t/ttname : \"모듈\"\n\t\t/ttdescript : \"모듈정의 하는 방법 입니다.\"\n\t},\n\t// Computed 와 같은 역할 \n\t// 사용할떄 한번만 사용, 데이터 바뀌면 감지해서 바뀜\n  getters: {},\n\t// 함수\n  mutations: {},\n\t// 비동기 처리 할떄 씀\n  actions: {};\n};\n          `),\n      },\n      {\n        title: \"TypeScirpt를 이용한 모듈 만들기 2\",\n        code: codeProcess(`\n        import { ActionTree, GetterTree, Module, MutationTree } from \"vuex\";\nimport { State as rootState } from \"../index\";\n\nexport interface IState {\n  rootName: string;\n  url: string;\n}\n\nconst state: IState = {\n  name: \"\",\n  age: \"\",\n};\n\nconst getters: GetterTree<IState, rootState> = {\n\n};\n\nconst mutations: MutationTree<IState> = {\n\n};\n\nconst actions: ActionTree<IState, rootState> = {\n\n};\n\nexport const module: Module<IState, rootState> = {\n\t// 호출할떄 [moduleName/호출] 로 호출\n\t// moduleName 은 modules에 정의된 모듈이름 따라감\n  // namespaced: true,\n  state,\n  getters,\n  mutations,\n  actions,\n  modules: {},\n};\n        `),\n      },\n    ]);\n    return { items };\n  },\n});\n</script>\n\n<style scoped></style>\n","\nimport { defineComponent, reactive } from \"vue\";\nimport { codeProcess } from \"@/components/codeConvert.vue\";\n\nexport default defineComponent({\n  setup() {\n    const items = reactive([\n      {\n        title: \"TypeScript를 이용한 index 정의\",\n        code: codeProcess(`// store/index.ts\n\n        import { InjectionKey } from \"vue\";\nimport { createStore, useStore as baseUseStore, Store } from \"vuex\";\n// 모듈 import\nimport { module as ModuleA , IModule as IModuleA  } from \"modules/moduleA\"\nimport { module as ModuleB , IModule as IModuleB  } from \"modules/moduleB\"\n\n\n// 인터페이스 정의\nexport interface State {\n\t/ttcount : number;\n\t/tttitle : string;\n\t/tt// 모듈 정의 \n\t/ttmoduleA ?: ImoduleA(module Interface)\n\t/ttmoduleB ?: ImoduleB(module Interface)\n}\n\n// Symbol를 이용한 키생성\nexport const key: InjectionKey<Store<State>> = Symbol();\n\n\n//store 정의\nexport const store = createStore<State>({\n  /ttstate: {\n  /tt/ttcount: 1,\n  /tt/tttitle: \"타이틀틀\"\n  /tt},\n  /tt// Computed 와 같은 역할\n/tt// 사용할떄 한번만 사용, 데이터 바뀌면 감지해서 바뀜\n/ttgetters: {},\n/tt// 함수\n/ttmutations: {},\n/tt// 비동기 처리 할떄 씀\n/ttactions: {};\n\t// 모듈 사용 ,\n\t/ttmodules : {\n\t/tt/ttmoduleA,\n\t/tt/ttmoduleB \n\t/tt}\n});\n\n// Composition Api에서 접근할떄 이함수를 사용\nexport function useStore(): Store<State> {\n  return baseUseStore(key);\n}`),\n      },\n      {\n        title: \"선언\",\n        code: codeProcess(`\n          //main.ts 선언\nimport { store, key } from \"./store/index\";\n\nvue.use(store , key);\n          `),\n      },\n      {\n        title: \"TypeScript를 이용한 모듈 만들기 1\",\n        code: codeProcess(`\n          // store/modules/module\nimport { Module } from \"vuex\";\nimport { State as rootState } from \"../index\";\n\ninterface IState{\n\t/ttname : string,\n\t/ttdescript : string;\n}\n\nexport const module :Module<IState, rootState> = {\n\t// 호출할떄 [moduleName/호출] 로 호출\n\t// moduleName 은 modules에 정의된 모듈이름 따라감\n  // namespaced: true, \n  // Data 와 같은 역할\n\tstate: { \n\t\t/ttname : \"모듈\"\n\t\t/ttdescript : \"모듈정의 하는 방법 입니다.\"\n\t},\n\t// Computed 와 같은 역할 \n\t// 사용할떄 한번만 사용, 데이터 바뀌면 감지해서 바뀜\n  getters: {},\n\t// 함수\n  mutations: {},\n\t// 비동기 처리 할떄 씀\n  actions: {};\n};\n          `),\n      },\n      {\n        title: \"TypeScirpt를 이용한 모듈 만들기 2\",\n        code: codeProcess(`\n        import { ActionTree, GetterTree, Module, MutationTree } from \"vuex\";\nimport { State as rootState } from \"../index\";\n\nexport interface IState {\n  rootName: string;\n  url: string;\n}\n\nconst state: IState = {\n  name: \"\",\n  age: \"\",\n};\n\nconst getters: GetterTree<IState, rootState> = {\n\n};\n\nconst mutations: MutationTree<IState> = {\n\n};\n\nconst actions: ActionTree<IState, rootState> = {\n\n};\n\nexport const module: Module<IState, rootState> = {\n\t// 호출할떄 [moduleName/호출] 로 호출\n\t// moduleName 은 modules에 정의된 모듈이름 따라감\n  // namespaced: true,\n  state,\n  getters,\n  mutations,\n  actions,\n  modules: {},\n};\n        `),\n      },\n    ]);\n    return { items };\n  },\n});\n","import { render } from \"./모듈정의.vue?vue&type=template&id=4a22de8a\"\nimport script from \"./모듈정의.vue?vue&type=script&lang=ts\"\nexport * from \"./모듈정의.vue?vue&type=script&lang=ts\"\nscript.render = render\n\nexport default script"],"sourceRoot":""}