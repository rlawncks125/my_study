{"version":3,"sources":["webpack:///./src/views/CS기술면접/네트워크.vue?d3fd","webpack:///./src/views/CS기술면접/네트워크.vue?c996","webpack:///./src/views/CS기술면접/네트워크.vue","webpack:///./src/views/CS기술면접/네트워크.vue?316c"],"names":["_hoisted_1","key","_hoisted_2","_hoisted_3","render","_ctx","_cache","$props","$setup","$data","$options","_directive_Accordion","items","item","id","title","dsc","class","innerHTML","detail","setup","trim","__exports__"],"mappings":"yIAAA,W,yDCEA,eAAa,mBACb,IAAMA,EAAa,CAAEC,IAAK,GACpBC,EAA0B,eAAoB,UAAW,KAAM,MAAO,GACtEC,EAAa,CAAC,aAGd,SAAUC,EAAOC,EAAUC,EAAYC,EAAYC,EAAYC,EAAWC,GAC9E,IAAMC,EAAuB,eAAkB,aAE/C,OAAQ,iBAAc,eAAoB,MAAO,KAAM,EACpD,gBAAW,GAAO,eAAoB,OAAW,KAAM,eAAYN,EAAKO,OAAO,SAACC,GAC/E,OAAQ,iBAAc,eAAoB,MAAO,CAC/CZ,IAAKY,EAAKC,IACT,CACD,eAAoB,KAAM,KAAM,eAAiBD,EAAKE,OAAQ,GAC7DF,EAAKG,KACD,iBAAc,eAAoB,KAAMhB,EAAY,eAAiBa,EAAKG,KAAM,IACjF,eAAoB,IAAI,GAC5B,eAAgB,eAAoB,UAAW,KAAM,CACnDd,EACA,eAAoB,MAAO,CACzBe,MAAO,UACPC,UAAWL,EAAKM,QACf,KAAM,EAAGhB,IACX,KAAM,CACP,CAACQ,UAGH,QAxBR,iB,cCHe,iBAAgB,CAC7BS,MAD6B,WAE3B,IAAMR,EAAQ,CACZ,CACEG,MAAO,qBACPI,OAAQ,49BAUNE,QAEJ,CACEN,MAAO,sBACPI,OAAQ,sBAENE,QAEJ,CACEN,MAAO,eACPI,OAAQ,wtCAYNE,QAEJ,CACEN,MAAO,cACPC,IAAK,uCACLG,OAAQ,8wGA6CNE,QAEJ,CACEN,MAAO,qBACPI,OAAQ,wmCAeNE,QAEJ,CACEN,MAAO,aACPI,OAAQ,yjFA+CNE,SAIN,MAAO,CAAET,Y,iCC7Jb,MAAMU,EAA2B,IAAgB,EAAQ,CAAC,CAAC,SAASlB,GAAQ,CAAC,YAAY,qBAE1E","file":"js/chunk-5c8b7d48.22e3ba93.js","sourcesContent":["export * from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../../node_modules/@vue/cli-service/node_modules/vue-loader-v16/dist/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/@vue/cli-service/node_modules/vue-loader-v16/dist/index.js??ref--0-1!./네트워크.vue?vue&type=style&index=0&id=6890525b&scoped=true&lang=css\"","import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, createCommentVNode as _createCommentVNode, resolveDirective as _resolveDirective, withDirectives as _withDirectives, withScopeId as _withScopeId, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\"\n\n_pushScopeId(\"data-v-6890525b\")\nconst _hoisted_1 = { key: 0 }\nconst _hoisted_2 = /*#__PURE__*/_createElementVNode(\"summary\", null, \"상세\", -1)\nconst _hoisted_3 = [\"innerHTML\"]\n_popScopeId()\n\nexport function render(_ctx: any,_cache: any,$props: any,$setup: any,$data: any,$options: any) {\n  const _directive_Accordion = _resolveDirective(\"Accordion\")!\n\n  return (_openBlock(), _createElementBlock(\"div\", null, [\n    (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, (item) => {\n      return (_openBlock(), _createElementBlock(\"div\", {\n        key: item.id\n      }, [\n        _createElementVNode(\"h2\", null, _toDisplayString(item.title), 1),\n        (item.dsc)\n          ? (_openBlock(), _createElementBlock(\"h4\", _hoisted_1, _toDisplayString(item.dsc), 1))\n          : _createCommentVNode(\"\", true),\n        _withDirectives(_createElementVNode(\"details\", null, [\n          _hoisted_2,\n          _createElementVNode(\"div\", {\n            class: \"content\",\n            innerHTML: item.detail\n          }, null, 8, _hoisted_3)\n        ], 512), [\n          [_directive_Accordion]\n        ])\n      ]))\n    }), 128))\n  ]))\n}","\nimport { defineComponent } from \"vue\";\n\nexport default defineComponent({\n  setup() {\n    const items = [\n      {\n        title: \"HTTP의 GET과 POST 비교\",\n        detail: `\n        <h3>GET</h3>\n        <p>우선 GET 방식은 요청하는 데이터가 <strong>HTTP Request Message</strong>의 Header 부분에 url 이 담겨서 전송된다. 때문에 url 상에 ? 뒤에 데이터가 붙어 request 를 보내게 되는 것이다. 이러한 방식은 url 이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다. 또 보안이 필요한 데이터에 대해서는 데이터가 그대로 url 에 노출되므로 GET방식은 적절하지 않다. (ex. password)</p>\n\n        <h3>POST</h3>\n        <p>POST 방식의 request 는 <strong>HTTP Request Message</strong>의 Body 부분에 데이터가 담겨서 전송된다. 때문에 바이너리 데이터를 요청하는 경우 POST 방식으로 보내야 하는 것처럼 데이터 크기가 GET 방식보다 크고 보안면에서 낫다.(하지만 보안적인 측면에서는 암호화를 하지 않는 이상 고만고만하다.)</p>\n\n        <p>그렇다면 이러한 특성을 이해한 뒤에는 어디에 적용되는지를 알아봐야 그 차이를 극명하게 이해할 수 있다. 우선 GET 은 가져오는 것이다. 서버에서 어떤 데이터를 가져와서 보여준다거나 하는 용도이지 서버의 값이나 상태 등을 변경하지 않는다. SELECT 적인 성향을 갖고 있다고 볼 수 있는 것이다. 반면에 POST 는 서버의 값이나 상태를 변경하기 위해서 또는 추가하기 위해서 사용된다.</p>\n\n        <p>부수적인 차이점을 좀 더 살펴보자면 GET 방식의 요청은 브라우저에서 Caching 할 수 있다. 때문에 POST 방식으로 요청해야 할 것을 보내는 데이터의 크기가 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청한다면 기존에 caching 되었던 데이터가 응답될 가능성이 존재한다. 때문에 목적에 맞는 기술을 사용해야 하는 것이다.</p>\n        `.trim(),\n      },\n      {\n        title: \"TCP 3-way Handshake\",\n        detail: `\n       \n        `.trim(),\n      },\n      {\n        title: \"TCP와 UDP의 비교\",\n        detail: `\n        <h3>UDP</h3>\n        <p><strong>UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)</strong>는 <strong>비연결형 프로토콜</strong> 이다. IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다. UDP는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다. 이 모두가 사용자 프로세스의 몫이다. UDP가 행하는 것은 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다.</p>\n\n        <p>종종 클라이언트는 서버로 짧은 요청을 보내고, 짧은 응답을 기대한다. 만약 요청 또는 응답이 손실된다면, 클라이언트는 time out 되고 다시 시도할 수 있으면 된다. 코드가 간단할 뿐만 아니라 TCP 처럼 초기설정(initial setup)에서 요구되는 프로토콜보다 적은 메시지가 요구된다.</p>\n\n        <p>UDP를 사용한 것들에는 DNS가 있다. 어떤 호스트 네임의 IP 주소를 찾을 필요가 있는 프로그램은, DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다. 이 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답한다. 사전에 설정이 필요하지 않으며 그 후에 해제가 필요하지 않다.</p>\n\n        <h3>TCP</h3>\n        <p>대부분의 인터넷 응용 분야들은 신뢰성 과 순차적인 전달 을 필요로 한다. UDP 로는 이를 만족시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 <strong>TCP</strong>이다. <strong>TCP(Transmission Control Protocol, 전송제어 프로토콜)</strong>는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송 하도록 특별히 설계되었다. TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. TCP 에서 연결 설정(connection establishment)는 3-way handshake를 통해 행해진다.</p>\n\n        <p>모든 TCP 연결은 전이중(full-duplex), 점대점(point to point)방식이다. 전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 의미하며 점대점이란 각 연결이 정확히 2 개의 종단점을 가지고 있음을 의미한다. TCP 는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.</p>\n        `.trim(),\n      },\n      {\n        title: \"HTTP와 HTTPS\",\n        dsc: \"HTTP 에 암호화와 인증, 그리고 완전성 보호를 더한 HTTPS\",\n        detail: `\n        <h3>HTTP 의 문제점</h3>\n        <ul>\n        <li>HTTP 는 평문 통신이기 때문에 도청이 가능하다.</li>\n        <li>통신 상대를 확인하지 않기 때문에 위장이 가능하다.</li>\n        <li>완전성을 증명할 수 없기 때문에 변조가 가능하다.</li>\n        </ul>\n        <span>위 세 가지는 다른 암호화하지 않은 프로토콜에도 공통되는 문제점들이다.</span>\n\n        <h3>TCP/IP 는 도청 가능한 네트워크이다.</h3>\n        <p>TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다. 패킷을 수집하는 것만으로 도청할 수 있다. 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화하여 통신해야 한다.</p>\n\n            <h4>보완 방법</h4>\n            <ul>\n            <li class='list-auto'>통신 자체를 암호화 SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 다른 프로토콜을 조합함으로써 HTTP 의 통신 내용을 암호화할 수 있다. SSL 을 조합한 HTTP 를 HTTPS(HTTP Secure) or HTTP over SSL이라고 부른다.</li>\n\n            <li class='list-auto'>콘텐츠를 암호화 말 그대로 HTTP 를 사용해서 운반하는 내용인, HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것이다. 암호화해서 전송하면 받은 측에서는 그 암호를 해독하여 출력하는 처리가 필요하다.</li>\n            </ul>\n        <h3>통신 상대를 확인하지 않기 때문에 위장이 가능하다.</h3>\n        <span>HTTP 에 의한 통신에는 상대가 누구인지 확인하는 처리는 없기 때문에 누구든지 리퀘스트를 보낼 수 있다. IP 주소나 포트 등에서 그 웹 서버에 액세스 제한이 없는 경우 리퀘스트가 오면 상대가 누구든지 무언가의 리스폰스를 반환한다. 이러한 특징은 여러 문제점을 유발한다.</span<\n        <ul>\n        <li class='list-auto'>리퀘스트를 보낸 곳의 웹 서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지를 확인할 수 없다.</li>\n        <li class='list-auto'>리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지를 확인할 수 없다.</li>\n        <li class='list-auto'>통신하고 있는 상대가 접근이 허가된 상대인지를 확인할 수 없다.</li>\n        <li class='list-auto'>어디에서 누가 리퀘스트 했는지 확인할 수 없다.</li>\n        <li class='list-auto'>의미없는 리퀘스트도 수신한다. —> DoS 공격을 방지할 수 없다.</li>\n        </ul>\n        <h4>보완 방법</h4>\n        <p>위 암호화 방법으로 언급된 <strong>SSL</strong>로 상대를 확인할 수 있다. SSL 은 상대를 확인하는 수단으로 증명서 를 제공하고 있다. 증명서는 신뢰할 수 있는 제 3 자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다. 이 증명서를 이용함으로써 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 이용자는 개인 정보 누설 등의 위험성이 줄어들게 된다. 한 가지 이점을 더 꼽자면 클라이언트는 이 증명서로 본인 확인을 하고 웹 사이트 인증에서도 이용할 수 있다.</p>\n\n        <h3>완전성을 증명할 수 없기 때문에 변조가 가능하다</h3>\n        <p>여기서 완전성이란 <strong>정보의 정확성</strong> 을 의미한다. 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다라는 것을 보장할 수 없는 것이다. 리퀘스트나 리스폰스가 발신된 후에 상대가 수신하는 사이에 누군가에 의해 변조되더라도 이 사실을 알 수 없다. 이와 같이 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 중간자 공격(Man-in-the-Middle)이라고 부른다.</p>\n        <h4>보완 방법</h4>\n        <p><strong>MD5</strong>, <strong>SHA-1</strong> 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 존재하지만 확실히 확인할 수 있는 것은 아니다. 확실히 방지하기에는 <strong>HTTPS</strong>를 사용해야 한다. SSL 에는 인증이나 암호화, 그리고 다이제스트 기능을 제공하고 있다.</p>\n\n        <h3>HTTPS</h3>\n        <p><strong>HTTPS</strong>는 SSL 의 껍질을 덮어쓴 HTTP 라고 할 수 있다. 즉, HTTPS 는 새로운 애플리케이션 계층의 프로토콜이 아니라는 것이다. HTTP 통신하는 소켓 부분을 <strong>SSL(Secure Socket Layer)</strong> or <strong>TLS(Transport Layer Security)</strong>라는 프로토콜로 대체하는 것 뿐이다. HTTP 는 원래 TCP 와 직접 통신했지만, HTTPS 에서 HTTP 는 <strong>SSL 과 통신하고 SSL 이 TCP 와 통신</strong> 하게 된다. SSL 을 사용한 HTTPS 는 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다.</p>\n\n        <p>HTTPS 의 SSL 에서는 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용한다. 공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식이다.</p>\n\n        <h4>모든 웹 페이지에서 HTTPS를 사용해도 될까?</h4>\n        <p>평문 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스를 더 많이 요구한다. 통신할 때마다 암호화를 하면 추가적인 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 리퀘스트의 수가 상대적으로 줄어들게 된다.</p>\n\n        <p>하지만 최근에는 하드웨어의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않으며, 새로운 표준인 HTTP 2.0을 함께 이용한다면 오히려 HTTPS가 HTTP보다 더 빠르게 동작한다. 따라서 웹은 과거의 민감한 정보를 다룰 때만 HTTPS에 의한 암호화 통신을 사용하는 방식에서 현재 모든 웹 페이지에서 HTTPS를 적용하는 방향으로 바뀌어가고 있다.</p>\n\n        `.trim(),\n      },\n      {\n        title: \"DNS round robin 방식\",\n        detail: `\n        <h4>DNS Round Robin 방식의 문제점</h4>\n        <ul>\n        <li class='list-auto'>서버의 수 만큼 공인 IP 주소가 필요함 부하 분산을 위해 서버의 대수를 늘리기 위해서는 그 만큼의 공인 IP 가 필요하다.</li>\n\n        <li class='list-auto'>균등하게 분산되지 않음 모바일 사이트 등에서 문제가 될 수 있는데, 스마트폰의 접속은 캐리어 게이트웨이 라고 하는 프록시 서버를 경유 한다. 프록시 서버에서는 이름변환 결과가 일정 시간 동안 캐싱되므로 같은 프록시 서버를 경유 하는 접속은 항상 같은 서버로 접속된다. 또한 PC 용 웹 브라우저도 DNS 질의 결과를 캐싱하기 때문에 균등하게 부하분산 되지 않는다. DNS 레코드의 TTL 값을 짧게 설정함으로써 어느 정도 해소가 되지만, TTL 에 따라 캐시를 해제하는 것은 아니므로 반드시 주의가 필요하다.</li>\n\n        <li class='list-auto'>서버가 다운되도 확인 불가 DNS 서버는 웹 서버의 부하나 접속 수 등의 상황에 따라 질의결과를 제어할 수 없다. 웹 서버의 부하가 높아서 응답이 느려지거나 접속수가 꽉 차서 접속을 처리할 수 없는 상황인 지를 전혀 감지할 수가 없기 때문에 어떤 원인으로 다운되더라도 이를 검출하지 못하고 유저들에게 제공한다. 이때문에 유저들은 간혹 다운된 서버로 연결이 되기도 한다. DNS 라운드 로빈은 어디까지나 부하분산 을 위한 방법이지 다중화 방법은 아니므로 다른 S/W 와 조합해서 관리할 필요가 있다.</li>\n        </ul>\n\n        <h4>Weighted round robin (WRR)</h4>\n        <p>각각의 웹 서버에 가중치를 가미해서 분산 비율을 변경한다. 물론 가중치가 큰 서버일수록 빈번하게 선택되므로 처리능력이 높은 서버는 가중치를 높게 설정하는 것이 좋다.</p>\n        <h4>Least connection</h4>\n        <p>접속 클라이언트 수가 가장 적은 서버를 선택한다. 로드밸런서에서 실시간으로 connection 수를 관리하거나 각 서버에서 주기적으로 알려주는 것이 필요하다.</p>\n\n        `.trim(),\n      },\n      {\n        title: \"웹 통신의 큰 흐름\",\n        detail: `\n        <p>우리가 Chrome 을 실행시켜 주소창에 특정 URL 값을 입력시키면 어떤 일이 일어나는가?</p>\n        <h4>in 브라우저</h4>\n        <ul>\n        <li class='list-auto'>url 에 입력된 값을 브라우저 내부에서 결정된 규칙에 따라 그 의미를 조사한다.</li>\n        <li class='list-auto'>조사된 의미에 따라 HTTP Request 메시지를 만든다.</li>\n        <li class='list-auto'>만들어진 메시지를 웹 서버로 전송한다.</li>\n        </ul>\n        <p>이 때 만들어진 메시지 전송은 브라우저가 직접하는 것이 아니다. 브라우저는 메시지를 네트워크에 송출하는 기능이 없으므로 OS에 의뢰하여 메시지를 전달한다. 우리가 택배를 보낼 때 직접 보내는게 아니라, 이미 서비스가 이루어지고 있는 택배 시스템(택배 회사)을 이용하여 보내는 것과 같은 이치이다. 단, OS에 송신을 의뢰할 때는 도메인명이 아니라 ip주소로 메시지를 받을 상대를 지정해야 하는데, 이 과정에서 DNS서버를 조회해야 한다.</p>\n        \n        <h4>in 프로토콜 스택, LAN 어댑터</h4>\n        <ul>\n        <li class='list-auto'>프로토콜 스택(운영체제에 내장된 네트워크 제어용 소프트웨어)이 브라우저로부터 메시지를 받는다.</li>\n        <li class='list-auto'>브라우저로부터 받은 메시지를 패킷 속에 저장한다.</li>\n        <li class='list-auto'>그리고 수신처 주소 등의 제어정보를 덧붙인다.</li>\n        <li class='list-auto'>그런 다음, 패킷을 LAN 어댑터에 넘긴다.</li>\n        <li class='list-auto'>LAN 어댑터는 다음 Hop의 MAC주소를 붙인 프레임을 전기신호로 변환시킨다.</li>\n        <li class='list-auto'>신호를 LAN 케이블에 송출시킨다.</li>\n        </ul>\n\n        <p>프로토콜 스택은 통신 중 오류가 발생했을 때, 이 제어 정보를 사용하여 고쳐 보내거나, 각종 상황을 조절하는 등 다양한 역할을 하게 된다. 네트워크 세계에서는 비서가 있어서 우리가 비서에게 물건만 건네주면, 받는 사람의 주소와 각종 유의사항을 써준다! 여기서는 프로토콜 스택이 비서의 역할을 한다고 볼 수 있다.</p>\n        <h4>in 허브, 스위치, 라우터</h4>\n        <ul>\n        <li class='list-auto'>LAN 어댑터가 송신한 프레임은 스위칭 허브를 경유하여 인터넷 접속용 라우터에 도착한다.</li>\n        <li class='list-auto'>라우터는 패킷을 프로바이더(통신사)에게 전달한다.</li>\n        <li class='list-auto'>인터넷으로 들어가게 된다.</li>\n        </ul>\n\n        <h4>in 액세스 회선, 프로바이더</h4>\n        <ul>\n        <li class='list-auto'>패킷은 인터넷의 입구에 있는 액세스 회선(통신 회선)에 의해 POP(Point Of Presence, 통신사용 라우터)까지 운반된다.</li>\n        <li class='list-auto'>POP 를 거쳐 인터넷의 핵심부로 들어가게 된다.</li>\n        <li class='list-auto'>수 많은 고속 라우터들 사이로 패킷이 목적지를 향해 흘러가게 된다.</li>\n        </ul>\n        <h4>in 방화벽, 캐시서버</h4>\n        <ul>\n        <li class='list-auto'>패킷은 인터넷 핵심부를 통과하여 웹 서버측의 LAN 에 도착한다.</li>\n        <li class='list-auto'>기다리고 있던 방화벽이 도착한 패킷을 검사한다.</li>\n        <li class='list-auto'>패킷이 웹 서버까지 가야하는지 가지 않아도 되는지를 판단하는 캐시서버가 존재한다.</li>\n        </ul>\n        <p>굳이 서버까지 가지 않아도 되는 경우를 골라낸다. 액세스한 페이지의 데이터가 캐시서버에 있으면 웹 서버에 의뢰하지 않고 바로 그 값을 읽을 수 있다. 페이지의 데이터 중에 다시 이용할 수 있는 것이 있으면 캐시 서버에 저장된다.</p>\n        <h4>in 웹 서버</h4>\n        <ul>\n        <li class='list-auto'>패킷이 물리적인 웹 서버에 도착하면 웹 서버의 프로토콜 스택은 패킷을 추출하여 메시지를 복원하고 웹 서버 애플리케이션에 넘긴다.</li>\n        <li class='list-auto'>메시지를 받은 웹 서버 애플리케이션은 요청 메시지에 따른 데이터를 응답 메시지에 넣어 클라이언트로 회송한다.</li>\n        <li class='list-auto'>왔던 방식대로 응답 메시지가 클라이언트에게 전달된다.</li>\n        </ul>\n        `.trim(),\n      },\n    ];\n\n    return { items };\n  },\n});\n","import { render } from \"./네트워크.vue?vue&type=template&id=6890525b&scoped=true&ts=true\"\nimport script from \"./네트워크.vue?vue&type=script&lang=ts\"\nexport * from \"./네트워크.vue?vue&type=script&lang=ts\"\n\nimport \"./네트워크.vue?vue&type=style&index=0&id=6890525b&scoped=true&lang=css\"\n\nimport exportComponent from \"/home/runner/work/my_study/my_study/node_modules/@vue/cli-service/node_modules/vue-loader-v16/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-6890525b\"]])\n\nexport default __exports__"],"sourceRoot":""}